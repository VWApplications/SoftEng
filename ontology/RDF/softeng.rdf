<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
   xmlns:ns1="http://purl.org/dc/elements/1.1/"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Definition_of_Problem_Solving">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Problem_Solving_Techniques"/>
    <ns1:title xml:lang="en">Definition of Problem Solving</ns1:title>
    <ns1:description xml:lang="en">
                Problem solving refers to the thinking and activities conducted
                to answer or derive a solution to a problem. There are many
                ways to approach a problem, and each way employs different
                tools and uses different processes. These different ways of
                approaching problems gradually expand and define themselves and
                finally give rise to different disciplines. For example,
                software engineering focuses on solving problems using
                computers and software. While different problems warrant
                different solutions and may require different tools and
                processes, the methodology and techniques used in solving
                problems do follow some guidelines and can often be generalized
                as problem solving techniques. For example, a general guideline
                for solving a generic engineering problem is to use the three-step
                process given below: Formulate the real problem; Analyze the
                problem; Design a solution search strategy.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_Concept_of_a_System">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Computing_Foundations"/>
    <ns1:title xml:lang="en">Basic Concept of a System</ns1:title>
    <ns1:description xml:lang="en">
                Ian Sommerville writes, “a system is a purposeful collection of
                interrelated components that work together to achieve some
                objective”. A system can be very simple and include only a few
                components, like an ink pen, or rather complex,
                like an aircraft. Depending on whether humans are part of the
                system, systems can be divided into technical computer-based
                systems and sociotechnical systems. A technical computer-based
                system functions without human involvement, such as
                televisions, mobile phones, thermostat, and some software; a
                sociotechnical system will not function without human
                involvement. Examples of such system include manned space
                vehicles, chips embedded inside a human, and so forth.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_Developer_Human_Factors">
    <ns1:title xml:lang="en">Basic Developer Human Factors</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Computing_Foundations"/>
    <ns1:description xml:lang="en">
                Developer human factors refer to the considerations of human
                factors taken when developing software. Software is developed by
                humans, read by humans, and maintained by humans. If anything is
                wrong, humans are responsible for correcting those wrongs. Thus, it
                is essential to write software in a way that is easily
                understandable by humans or, at the very least, by other software
                developers. A program that is easy to read and understand exhibits
                readability. The means to ensure that software meet this objective
                are numerous and range from proper
                architecture at the macro level to the particular coding style and
                variable usage at the micro level. But the two prominent factors
                are structure (or program layouts) and comments(documentation).
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Programming_Fundamentals">
    <ns1:title xml:lang="en">Programming Fundamentals</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Computing_Foundations"/>
    <ns1:description xml:lang="en">
                Programming is composed of the methodologies or activities for
                creating computer programs that perform a desired function. It
                is an indispensible part in software construction. In general,
                programming can be considered as the process of designing,
                writing, testing, debugging, and maintaining the source code.
                This source code is written in a programming language. The
                process of writing source code often requires expertise in many
                different subject areas including knowledge of the application
                domain, appropriate data structures, specialized algorithms,
                various language constructs, good programming techniques, and
                software engineering.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Overview_of_a_Computer_System">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_Concept_of_a_System"/>
    <ns1:title xml:lang="en">Overview of a Computer System</ns1:title>
    <ns1:description xml:lang="en">
                Among all the systems, one that is obviously relevant to the
                software engineering community is the computer system. A
                computer is a machine that executes programs or software. It
                consists of a purposeful collection of mechanical, electrical,
                and electronic components with each component performing a
                preset function. Jointly, these components are able to execute
                the instructions that are given by the program. Abstractly
                speaking, a computer receives some input, stores and
                manipulates some data, and provides some output. The most
                distinct feature of a computer is its ability to store and
                execute sequences of instructions called programs. An
                interesting phenomenon concerning the computer is the universal
                equivalence in functionality. According to Turing, all
                computers with a certain minimum capability are equivalent in
                their ability to perform computation tasks. In other words,
                given enough time and memory, all computers ranging from a
                netbook to a supercomputer are capable of computing exactly the
                same things, irrespective of speed, size, cost, or anything else. Most
                computer systems have a structure that is known as the “von
                Neumann model,” which consists of five components: a memory for
                storing instructions and data, a central processing unit
                for performing arithmetic and logical operations, a control
                unit for sequencing and interpreting instructions, input for
                getting external information into the memory, and output for
                producing results for the user.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Error_Messages">
    <ns1:title xml:lang="en">Error Messages</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_User_Human_Factors"/>
    <ns1:description xml:lang="en">
                It is understandable that most software contains faults and
                fails from time to time. But users should be notified if there
                is anything that impedes the smooth execution of the program.
                Nothing is more frustrating than an unexpected termination or
                behavioral deviation of software without any warning or
                explanation. To be user friendly, the software should report
                all error conditions to the users or upper-level applications
                so that some measure can be taken to rectify the situation or
                to exit gracefully. There are several guidelines that define
                what constitutes a good error message: error messages should be
                clear, to the point, and timely. First, error messages should
                clearly explain what is happening so that users know what is
                going on in the software. Second, error messages should
                pinpoint the cause of the error, if at all possible, so that
                proper actions can be taken. Third, error messages should be
                displayed right when the error condition occurs. According to
                Jakob Nielsen, “Good error messages should be expressed in
                plain language (no codes), precisely indicate the problem, and
                constructively suggest a solution”. Fourth, error messages
                should not overload the users with too much information and
                cause them to ignore the messages all together. However,
                messages relating to security access errors should not provide
                extra information that would help unauthorized persons break
                in.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Algorithmic_Analysis">
    <ns1:title xml:lang="en">Algorithmic Analysis</ns1:title>
    <ns1:description xml:lang="en">
                Analysis of algorithms is the theoretical study of
                computer-program performance and resource usage; to some extent
                it determines the goodness of an algorithm. Such analysis
                usually abstracts away the particular details of a specific
                computer and focuses on the asymptotic, machine-independent
                analysis. There are three basic types of analysis. In
                worst-case analysis, one determines the maximum time or
                resources required by the algorithm on any input of size n. In
                average-case analysis, one determines the expected time or
                resources required by the algorithm over all inputs of size n;
                in performing average-case analysis, one often needs to make
                assumptions on the statistical distribution of inputs. The
                third type of analysis is the best-case analysis, in which one
                determines the minimum time or resources required by the
                algorithm on any input of size n. Among the three types of
                analysis, average-case analysis is the most relevant but also
                the most difficult to perform.
                Besides the basic analysis methods, there are also the
                amortized analysis, in which one determines the maximum time
                required by an algorithm over a sequence of operations; and the
                competitive analysis, in which one determines the relative
                performance merit of an algorithm against the optimal algorithm
                (which may not be known) in the same category (for the same operations).
            </ns1:description>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Algorithms_and_Complexity"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Algorithms_and_Complexity">
    <ns1:title xml:lang="en">Algorithms and Complexity</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Computing_Foundations"/>
    <ns1:description xml:lang="en">
                Programs are not random pieces of code: they are meticulously
                written to perform user-expected actions. The guide one uses to
                compose programs are algorithms, which organize various
                functions into a series of steps and take into consideration
                the application domain, the solution strategy, and the data
                structures being used. An algorithm can be very simple or very
                complex.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Structure">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_Developer_Human_Factors"/>
    <ns1:title xml:lang="en">Structure</ns1:title>
    <ns1:description xml:lang="en">
                Well-structured programs are easier to understand and modify.
                If a program is poorly structured, then no amount of
                explanation or comments is sufficient to make it
                understandable. The ways to organize a program are numerous and
                range from the proper use of white space, indentation, and
                parentheses to nice arrangements of groupings, blank lines, and
                braces. Whatever style one chooses, it should be consistent
                across the entire program.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Analyze_the_Problem">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Problem_Solving_Techniques"/>
    <ns1:description xml:lang="en">
                Once the problem statement is available, the next step is to
                analyze the problem statement or situation to help structure
                our search for a solution. Four types of analysis include
                situation analysis, in which the most urgent or critical
                aspects of a
                situation are identified first; problem analysis, in which the
                cause of the problem must be determined; decision analysis, in
                which the action(s) needed to correct the problem or eliminate
                its cause must be determined; and potential problem analysis,
                in which the action(s) needed to prevent any reoccurrences of
                the problem or the development of new problems must be
                determined.
            </ns1:description>
    <ns1:title xml:lang="en">Analyze the Problem</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Computing_Foundations">
    <ns1:description xml:lang="en">
                The scope of the Computing Foundations knowledge area (KA)
                encompasses the development and operational environment in which
                software evolves and executes. Because no software can exist in a
                vacuum or run without a computer, the core of such an environment
                is the computer and its various components. Knowledge about the
                computer and its underlying principles of hardware and software
                serves as a framework on which software engineering is anchored.
                Thus, all software engineers must have good understanding of the
                Computing Foundations KA. It is generally accepted that software
                engineering builds on top of computer science. For example,
                “Software Engineering 2004: Curriculum Guidelines for Undergraduate
                Degree Programs in Software Engineering” clearly states, “One
                particularly important aspect is that software engineering builds
                on computer science and mathematics” (italics added).
            </ns1:description>
    <ns1:title xml:lang="en">Computing Foundations</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Knowledge_Area"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Attributes_of_Algorithms">
    <ns1:description xml:lang="en">
                The attributes of algorithms are many and often include
                modularity, correctness, maintainability, functionality,
                robustness, user-friendliness (i.e. easy to be understood by
                people), programmer time, simplicity, and extensibility. A
                commonly emphasized attribute is “performance” or
                “efficiency” by which we mean both time and resource-usage
                efficiency while generally emphasizing the time axis. To
                some degree, efficiency determines if an algorithm is
                feasible or impractical. For example, an algorithm that
                takes one hundred years to terminate is virtually useless
                and is even considered incorrect.
            </ns1:description>
    <ns1:title xml:lang="en">Attributes of Algorithms</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Algorithms_and_Complexity"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Programming_Paradigms">
    <ns1:description xml:lang="en">
                Programming is highly creative and thus somewhat personal.
                Different people often write different programs for the same
                requirements. This diversity of programming causes much
                difficulty in the construction and maintenance of large complex
                software. Various programming paradigms have been developed
                over the years to put some standardization into this highly
                creative and personal activity. When one programs, he or she
                can use one of several programming paradigms to write the code.
                Unstructured Programming: In unstructured programming, a
                programmer follows his/her hunch to write the code in whatever
                way he/she likes as long as the function is operational. Often,
                the practice is to write code to fulfill a specific utility
                without regard to anything else. Programs written this way
                exhibit no particular structure thus the name “unstructured
                programming.” Unstructured programming is also sometimes called
                ad hoc programming. Structured/Procedural/ Imperative
                Programming: A hallmark of structured programming is the use of
                well-defined control structures, including procedures (and/or
                functions) with each procedure (or function) performing a
                specific task.
                Object-Oriented Programming: While procedural programming
                organizes programs around procedures, object-oriented
                programming (OOP) organize a program around objects, which are
                abstract data structures that combine both data
                and methods used to access or manipulate the data.
            </ns1:description>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Programming_Fundamentals"/>
    <ns1:title xml:lang="en">Programming Paradigms</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Emergent_System_Properties">
    <ns1:title xml:lang="en">Emergent System Properties</ns1:title>
    <ns1:description xml:lang="en">
                A system is more than simply the sum of its parts. Thus, the
                properties of a system are not simply the sum of the properties of
                its components. Instead, a system often exhibits properties that
                are properties of the system as a whole. These properties are
                called emergent properties because they develop only after the
                integration of constituent parts in the system. Emergent system
                properties can be either functional or nonfunctional. Functional
                properties describe the things that a system does. For example, an
                aircraft’s functional properties include flotation on air, carrying
                people or cargo, and use as a weapon of mass destruction.
                Nonfunctional properties describe how the system behaves in its operational
                environment. These can include such qualities as consistency, capacity, weight,
                security, etc.
            </ns1:description>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_Concept_of_a_System"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Hierarchy">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Abstraction"/>
    <ns1:description xml:lang="en">
                When we use abstraction in our problem formulation and
                solution, we may use different abstractions at different times
                in other words, we work on different levels of abstraction as
                the situation calls. Most of the time, these different levels
                of abstraction are organized in a hierarchy. There are many
                ways to structure a particular hierarchy and the criteria used
                in determining the specific content of each layer in the
                hierarchy varies depending on the individuals performing the
                work. Sometimes, a hierarchy of abstraction is sequential,
                which means that each layer has one and only one predecessor
                (lower) layer and one and only one successor (upper) layer
                except the upmost layer (which has no successor) and the
                bottommost layer (which has no predecessor). Sometimes,
                however, the hierarchy is organized in a tree-like structure,
                which means each layer can have more than one predecessor layer
                but only one successor layer. Occasionally, a hierarchy can
                have a manyto-many structure, in which each layer can have
                multiple predecessors and successors. At no time, shall there
                be any loop in a hierarchy. A hierarchy often forms naturally
                in task decomposition. Often, a task analysis can be decomposed
                in a hierarchical fashion, starting with the larger tasks and
                goals of the organization and breaking each of them down into
                smaller subtasks that can again be further subdivided This
                continuous division of tasks into smaller ones would produce a
                hierarchical structure of tasks-subtasks.
            </ns1:description>
    <ns1:title xml:lang="en">Hierarchy</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Overview_of_Algorithms">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Algorithms_and_Complexity"/>
    <ns1:description xml:lang="en">
                Abstractly speaking, algorithms guide the operations of
                computers and consist of a sequence of actions composed to
                solve a problem. Alternative definitions include but are not
                limited to: An algorithm is any well-defined computational
                procedure that takes some value or set of values as input and
                produces some value or set of values as output; An algorithm is
                a sequence of computational steps that transform the input into
                the output; An algorithm is a tool for solving a wellspecified
                computation problem. Of course, different definitions are
                favored by different people. Though there is no universally
                accepted definition, some agreement exists
                that an algorithm needs to be correct, finite (in other words,
                terminate eventually or one must be able to write it in a
                finite number of steps), and unambiguous.
            </ns1:description>
    <ns1:title xml:lang="en">Overview of Algorithms</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Comments">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_Developer_Human_Factors"/>
    <ns1:title xml:lang="en">Comments</ns1:title>
    <ns1:description xml:lang="en">
                To most people, programming is coding. These people do not
                realize that programming also includes writing comments and
                that comments are an integral part of programming. True,
                comments are not used by the computer and certainly do not
                constitute final instructions for the computer, but they
                improve the readability of the programs by explaining the
                meaning and logic of the statements or sections of code. It
                should be remembered that programs are not only meant for
                computers, they are also read, written, and modified by humans.
                The types of comments include repeat of the code, explanation
                of the code, marker of the code, summary of the code,
                description of the code’s intent, and information that cannot
                possibly be expressed by the code itself. Some comments are
                good, some are not. The good ones are those that explain the
                intent of the code and justify why this code looks the way it
                does. The bad ones are repeat of the code and stating
                irrelevant information. The best comments are selfdocumenting
                code. If the code is written in such a clear and precise manner
                that its meaning is selfproclaimed, then no comment is needed.
                But this is easier said than done. Most programs are not
                self-explanatory and are often hard to read and understand if
                no comments are given.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Levels_of_Abstraction">
    <ns1:description xml:lang="en">
                When abstracting, we concentrate on one “level” of the
                big picture at a time with confidence that we can then
                connect effectively with levels above and below. Although
                we focus on one level, abstraction does not mean knowing
                nothing about the neighboring levels. Abstraction levels
                do not necessarily correspond to discrete components in
                reality or in the problem domain, but to welldefined
                standard interfaces such as programming APIs. The advantages
                that standard interfaces provide include portability, easier
                software/hardware integration and wider usage.
            </ns1:description>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Abstraction"/>
    <ns1:title xml:lang="en">Levels of Abstraction</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Algorithmic_Design_Strategies">
    <ns1:description xml:lang="en">
                The design of algorithms generally follows one of the following
                strategies: brute force, divide and conquer, dynamic
                programming, and greedy selection. The brute force strategy is
                actually a no-strategy. It exhaustively tries every possible
                way to tackle a problem. If a problem has a solution, this
                strategy is guaranteed to find it; however, the time expense
                may be too high. The divide and conquer strategy improves on
                the brute force strategy by dividing a big problem into
                smaller, homogeneous problems. It solves the big problem by
                recursively solving the smaller problems and combing the
                solutions to the smaller problems to form the solution to the
                big problem. The underlying assumption for divide and conquer
                is that smaller problems are easier to solve. The dynamic
                programming strategy improves on the divide and conquer
                strategy by recognizing that some of the sub-problems produced
                by division may be the same and thus avoids solving the same
                problems again and again. This elimination of redundant
                subproblems can dramatically improve efficiency. The greedy
                selection strategy further improves
                on dynamic programming by recognizing that not all of the
                sub-problems contribute to the solution of the big problem. By
                eliminating all but one sub-problem, the greedy selection
                strategy achieves the highest efficiency among all algorithm
                design strategies. Sometimes the use of randomization can
                improve on the greedy selection strategy by eliminating the
                complexity in determining the greedy choice through coin
                flipping or randomization.
            </ns1:description>
    <ns1:title xml:lang="en">Algorithmic Design Strategies</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Algorithms_and_Complexity"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Design_a_Solution_Search_Strategy">
    <ns1:description xml:lang="en">
                Once the problem analysis is complete, we can focus on
                structuring a search strategy to find the solution. In order to
                find the “best” solution (here, “best” could mean different
                things to different people, such as faster, cheaper, more
                usable, different capabilities, etc.), we need to eliminate
                paths that do not lead to viable solutions, design tasks in
                a way that provides the most guidance in searching for a
                solution, and use various attributes of the final solution
                state to guide our choices in the problem solving process.
            </ns1:description>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Problem_Solving_Techniques"/>
    <ns1:title xml:lang="en">Design a Solution Search Strategy</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Algorithmic_Analysis_Strategies">
    <ns1:description xml:lang="en">
                The analysis strategies of algorithms include basic counting
                analysis, in which one actually counts the number of steps an
                algorithm takes to complete its task; asymptotic analysis, in
                which one only considers the order of magnitude of the number
                of steps an algorithm takes to complete its task; probabilistic
                analysis, in which one makes use of probabilities in analyzing
                the average performance of an algorithm; amortized analysis, in
                which one uses the methods of aggregation, potential, and
                accounting to analyze the worst performance of an algorithm on
                a sequence of operations; and competitive analysis, in which
                one uses methods such as potential and accounting to analyze
                the relative performance of an algorithm to the optimal
                algorithm. For complex problems and algorithms, one may need to
                use a combination of the aforementioned analysis strategies.
            </ns1:description>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Algorithms_and_Complexity"/>
    <ns1:title xml:lang="en">Algorithmic Analysis Strategies</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Formulating_the_Real_Problem">
    <ns1:description xml:lang="en">
                Gerard Voland writes, “It is important to recognize that a
                specific problem should be formulated if one is to develop a
                specific solution”. This formulation is called the problem
                statement, which explicitly specifies what both the problem and
                the desired outcome are. Although there is no universal way of
                stating a problem, in general a problem should be expressed in
                such a way as to facilitate the development of solutions. Some
                general techniques to help one formulate the real problem
                include statement-restatement, determining the source and the
                cause, revising the statement, analyzing present and desired
                state, and using the fresh eye
                approach.
            </ns1:description>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Problem_Solving_Techniques"/>
    <ns1:title xml:lang="en">Formulating the Real Problem</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/The_Programming_Process">
    <ns1:title xml:lang="en">The Programming Process</ns1:title>
    <ns1:description xml:lang="en">
                Programming involves design, writing, testing, debugging, and
                maintenance. Design is the conception or invention of a scheme
                for turning a customer requirement for computer software into
                operational software. It is the activity that links application
                requirements to coding and debugging. Writing is the actual
                coding of the design in an appropriate programming language.
                Testing is the activity to verify that the code one writes
                actually does what it is supposed to do. Debugging is the
                activity to find and fix bugs (faults) in the source code (or
                design). Maintenance is the activity to update, correct, and
                enhance existing programs.
            </ns1:description>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Programming_Fundamentals"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Alternate_Abstraction">
    <ns1:description xml:lang="en">
                Sometimes it is useful to have multiple alternate
                abstractions for the same problem so that one can
                keep different perspectives in mind. For example,
                we can have a class diagram, a state chart, and a
                sequence diagram for the same software at the same
                level of abstraction. These alternate abstractions
                do not form a hierarchy but rather complement each
                other in helping understanding the problem and its
                solution. Though beneficial, it is as times difficult
                to keep alternate abstractions in sync.
            </ns1:description>
    <ns1:title xml:lang="en">Alternate Abstraction</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Abstraction"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Systems_Engineering">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_Concept_of_a_System"/>
    <ns1:title xml:lang="en">Systems Engineering</ns1:title>
    <ns1:description xml:lang="en">
                “Systems engineering is the interdisciplinary approach
                governing the total technical and managerial effort required to
                transform a set of customer needs, expectations, and
                constraints into a solution and to support that solution
                throughout its life.”. The life cycle stages of systems
                engineering vary depending on the system being
                built but, in general, include system requirements definition,
                system design, sub-system development, system integration,
                system testing, system installation, system evolution, and
                system decommissioning. Many practical guidelines have been
                produced in the past to aid people in performing the activities
                of each phase. For example, system design can be broken into
                smaller tasks of identification of subsystems, assignment of
                system requirements to subsystems, specification of subsystem
                functionality, definition of sub-system interfaces, and so
                forth.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Software_Robustness">
    <ns1:description xml:lang="en">
                Software robustness refers to the ability of software to
                tolerate erroneous inputs. Software is said to be robust if it
                continues to function even when erroneous inputs are given.
                Thus, it is unacceptable for software to simply crash when
                encountering
                an input problem as this may cause unexpected consequences,
                such as the loss of valuable data. Software that exhibits such
                behavior is considered to lack robustness. Nielsen gives a
                simpler description of software robustness: “The software
                should have a low error rate, so that users make few errors
                during the use of the system and so that if they do make errors
                they can easily recover from them. Further,
                catastrophic errors must not occur”. There are many ways to
                evaluate the robustness of software and just as many ways to
                make software more robust. For example, to improve robustness,
                one should always check the validity of the inputs and return
                values before progressing further; one should always throw an
                exception
                when something unexpected occurs, and one should never quit a
                program without first giving users/applications a chance to
                correct the condition.
            </ns1:description>
    <ns1:title xml:lang="en">Software Robustness</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_User_Human_Factors"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Problem_Solving_Techniques">
    <ns1:title xml:lang="en">Problem Solving Techniques</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Computing_Foundations"/>
    <ns1:description xml:lang="en">
                The concepts, notions, and terminology introduced here form an
                underlying basis for understanding the role and scope of
                problem solving techniques.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_User_Human_Factors">
    <ns1:description xml:lang="en">
                Software is developed to meet human desires or needs. Thus, all
                software design and development must take into consideration
                human-user factors such as how people use software, how people
                view software, and what humans expect from software. There are
                numerous factors in the human-machine interaction, and ISO 9241
                document series define all the detailed standards of such
                interactions. But the basic human-user factors considered
                here include input/output, the handling of error messages, and
                the robustness of the software in general.
            </ns1:description>
    <ns1:title xml:lang="en">Basic User Human Factors</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Computing_Foundations"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Problem_Solving_Using_Programs">
    <ns1:title xml:lang="en">Problem Solving Using Programs</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Problem_Solving_Techniques"/>
    <ns1:description xml:lang="en">
                The uniqueness of computer software gives problem solving a
                flavor that is distinct from general engineering problem
                solving. To solve a problem using computers, we must answer the
                following questions. How do we figure out what to tell the
                computer to do? How do we convert the problem statement into an
                algorithm? How do we convert the algorithm into machine
                instructions? The first task in solving a problem using a
                computer is to determine what to tell the computer to
                do. There may be many ways to tell the story, but all should
                take the perspective of a computer such that the computer can
                eventually solve the problem. In general, a problem should be
                expressed in such a way as to facilitate the development of
                algorithms and data structures for solving it. The result of
                the first task is a problem statement. The next step is to
                convert the problem statement into algorithms that solve the
                problem. Once an algorithm is found, the final step converts
                the algorithm into machine instructions that form the final
                solution: software that solves the problem. Abstractly
                speaking, problem solving using a computer can be considered as
                a process of problem transformation in other words, the
                step-bystep
                transformation of a problem statement into a problem solution.
                To the discipline of software engineering, the ultimate
                objective of problem solving is to transform a problem
                expressed in natural language into electrons running around a
                circuit.
            </ns1:description>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Abstraction">
    <ns1:description xml:lang="en">
                Abstraction is an indispensible technique associated
                with problem solving. It refers to both the process
                and result of generalization by reducing the information
                of a concept, a problem, or an observable phenomenon so
                that one can focus on the “big picture.” One of the most
                important skills in any engineering undertaking is framing
                the levels of abstraction appropriately. “Through abstraction,”
                according to Voland, “we view the problem and its possible
                solution paths from a higher level of conceptual understanding.
                As a result, we may become better prepared to recognize possible
                relationships between different aspects of the problem and thereby
                generate more creative design solutions”. This is particularly
                true in computer science in general (such as hardware vs.
                software) and in software engineering in particular (data structure
                vs. data flow, and so forth).
            </ns1:description>
    <ns1:title xml:lang="en">Abstraction</ns1:title>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Computing_Foundations"/>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/User_Input_and_Output">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Basic_User_Human_Factors"/>
    <ns1:description xml:lang="en">
                Input and output are the interfaces between users and software.
                Software is useless without input and output. Humans design
                software to process some input and produce desirable output.
                All software engineers must consider input and output as an
                integral part of the software product they engineer or develop.
                Issues considered for input include (but are not limited to):
                What input is required? How is the input passed from users to
                computers? What is the most convenient way for users to
                enter input? What format does the computer require of the input
                data? The designer should request the minimum data from human
                input, only when the data is not already stored in the system.
                The designer should format and edit the data at the time of
                entry to reduce errors arising from incorrect or malicious data
                entry. For output, we need to consider what the users wish to
                see: In what format would users like to see output? What is the
                most pleasing way to display output? If the party interacting
                with the software isn’t human but another software or computer
                or control system, then we need to consider the input/output
                type and format that the software should produce to ensure
                proper data exchange between systems. There are many rules of
                thumb for developers to follow to produce good input/output for
                a software.
            </ns1:description>
    <ns1:title xml:lang="en">User Input and Output</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Knowledge_Area">
    <ns1:description xml:lang="en">
                A body of knowledge or Knowledge area is the complete set of concepts,
                terms and activities that make up a professional domain, as defined by the
                relevant learned society or professional association. It is a type of
                knowledge representation by any knowledge organization. A BOK/KA is the
                accepted ontology for a specific domain. A BOK/KA is more than simply a
                collection of terms; a professional reading list; a library; a website or a
                collection of websites; a description of professional functions; or even a
                collection of information.
                </ns1:description>
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Knowledge_Domain"/>
    <ns1:title xml:lang="en">Knowledge Area</ns1:title>
  </rdf:Description>
  <rdf:Description rdf:about="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Encapsulation">
    <rdfs:subClassOf rdf:resource="http://www.semanticweb.org/ontologies/2018/Software_Engineering/Abstraction"/>
    <ns1:description xml:lang="en">
                Encapsulation is a mechanism used to implement abstraction.
                When we are dealing with one level of abstraction, the
                information concerning the levels below and above that level is
                encapsulated. This information can be the concept, problem, or
                observable phenomenon; or it may be the permissible operations
                on these relevant entities. Encapsulation usually comes with
                some degree of information hiding in which some or all of the
                underlying details are hidden from the level above the
                interface provided by the abstraction. To an object,
                information hiding means we don’t need to know the details of
                how the object is represented or how the operations on those
                objects are implemented.
            </ns1:description>
    <ns1:title xml:lang="en">Encapsulation</ns1:title>
  </rdf:Description>
</rdf:RDF>
